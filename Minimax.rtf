{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
{\f529\froman\fcharset238\fprq2 Times New Roman CE;}{\f530\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f532\froman\fcharset161\fprq2 Times New Roman Greek;}{\f533\froman\fcharset162\fprq2 Times New Roman Tur;}
{\f534\froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f535\froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f536\froman\fcharset186\fprq2 Times New Roman Baltic;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;
\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;
\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang2057\langfe1033\cgrid\langnp2057\langfenp1033 \snext0 Normal;}{\*\cs10 \additive Default Paragraph Font;}{
\s15\qc \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 \b\fs28\lang1031\langfe1033\cgrid\langnp1031\langfenp1033 \sbasedon0 \snext15 Title;}{\s16\ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 \fs20\lang1031\langfe1033\cgrid\langnp1031\langfenp1033 
\sbasedon0 \snext16 Body Text;}}{\*\listtable{\list\listtemplateid530469450\listsimple{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat0\levelspace0\levelindent0{\leveltext\'01*;}{\levelnumbers;}\chbrdr\brdrnone\brdrcf1 
\chshdng0\chcfpat1\chcbpat1 }{\listname ;}\listid-2}}{\*\listoverridetable{\listoverride\listid-2\listoverridecount1{\lfolevel\listoverrideformat{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat0\levelold\levelspace0
\levelindent360{\leveltext\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 }}\ls1}}{\info{\author Mark Baker-Munton}{\operator Mark Baker-Munton}{\creatim\yr2000\mo8\dy11\hr12\min38}
{\revtim\yr2000\mo8\dy11\hr13\min28}{\version2}{\edmins11}{\nofpages5}{\nofwords2938}{\nofchars13009}{\*\company Infostrategy Ltd}{\nofcharsws15955}{\vern8247}}
\widowctrl\ftnbj\aenddoc\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\hyphcaps0\horzdoc\dghspace120\dgvspace120\dghorigin1701\dgvorigin1984\dghshow0\dgvshow3\jcompress\viewkind1\viewscale100\nolnhtadjtbl \fet0\sectd \linex0\sectdefaultcl 
{\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5
\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang
{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \s15\qc \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 \b\fs28\lang1031\langfe1033\cgrid\langnp1031\langfenp1033 {The MiniMax Algorithm
\par }\pard\plain \ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 \fs24\lang2057\langfe1033\cgrid\langnp2057\langfenp1033 {\fs20\lang1031\langfe1033\langnp1031 
\par }\pard\plain \s16\ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 \fs20\lang1031\langfe1033\cgrid\langnp1031\langfenp1033 {
The MiniMax Algorithm was developed by Claude Shannon in the 1950's in an attempt to teach computers how to play two players games against a human opponent. Since at that time it was not possible to implement the algorithm on the ste
am-driven computers of those days Shannon implemented the algorithm in writing and it is known that he played two or three games of chess (on a reduced six by six board with no knights) against a piece of paper and a pencil. Unfortunately the outcome of t
hese games is unknown.
\par }\pard\plain \ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 \fs24\lang2057\langfe1033\cgrid\langnp2057\langfenp1033 {\fs20\lang1031\langfe1033\langnp1031 
\par Now, to understand what this algorithm is about let's look at how opponents play this type of games. We will call the two opponents Black and White.
\par 
\par When it is White's turn he will of course choose a move that }{\b\fs20\lang1031\langfe1033\langnp1031 maxi}{\fs20\lang1031\langfe1033\langnp1031 mizes his advantag
e over Black; Black on the other side does exactly the same for himself; however seeing Black through White's eyes, Black is trying to }{\b\fs20\lang1031\langfe1033\langnp1031 mini}{\fs20\lang1031\langfe1033\langnp1031 
mize White's advantage. This is what's given the algorithm it's name.
\par 
\par Our first approach to implement an algorithm to find our best move could be: 
\par 
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 Copy the internal representation of the current board into a temporary store
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 Generate all legal moves for the side who's turn it is
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 If there are no legal moves the side to move has lost - return a Result to indicate this 
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 For each legal move generated:
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 \tab Use the temporary board to try that move 
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 \tab Evaluate the resulting position
\par }\pard \ql \li0\ri0\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\faauto\rin0\lin0\itap0 {\fs20\lang1031\langfe1033\langnp1031 \tab If the evaluation result is better than than any previous result then save the move leading to it as the 
\par \tab Best Move
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 Return the Best Move
\par }\pard \ql \li0\ri0\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\faauto\rin0\lin0\itap0 {\fs20\lang1031\langfe1033\langnp1031 
\par On the 'real' board make that move.
\par 
\par That's the maximize part of the Minimax Algorithm.
\par 
\par As in real life it's not that easy of course, because after White has made his move it is Black's turn and he will minimize the board's evaluation result. So to see how good our
 'best' move really is we would have to defer the evaluation until after Black's move. The same is true for Black also, to find his best move he will have to wait until after our response to his move.
\par 
\par So we have to modify our goal: Find the best move that our opponent permits. This leads to a recursive algorithm; none of the players can evaluate the board until after the opponent has made his answering move:
\par 
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 Copy the internal representation of the current board into a temporary store
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 Generate all legal moves for the side who's turn it is
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 If there are no legal moves then the side to move has lost - return a Result to indicate this 
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 Else
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 \tab For each legal move generated:
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 \tab \tab Use the temporary board to try that move 
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 \tab \tab Perform a minimizing buddy algorithm for the opponent
\par }\pard \ql \li0\ri0\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\faauto\rin0\lin0\itap0 {\fs20\lang1031\langfe1033\langnp1031 \tab \tab If the result returned by the buddy is better than any previous result then save the move leading to \tab 
\tab it as the Best Move
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 \tab Return the Best Move and the Best Result
\par }\pard \ql \li0\ri0\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\faauto\rin0\lin0\itap0 {\fs20\lang1031\langfe1033\langnp1031 
\par On the 'real' board make that move 
\par 
\par This modified algorithm will analyse all possible moves right to the end of the game and return the move leading towards winning.
\par 
\par This may be OK for trivial games like TicTacToe where the end of the game is only nine moves away; however even with TicTacToe the algorithm will have to explore 9! o
r  362880 positions. With more sophisticated games there will be an exposion in search tree size and it is not possible to explore the complete game before making a move. So we have to stop recursion before the whole search tree is explored and we simply 
modify the algorithm as follows:
\par 
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 Copy the internal representation of the current board into a temporary store
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 Generate all legal moves for the side who's turn it is
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 If there are no legal moves then the side to move has lost - return a Result to indicate this 
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 If a specific recursion depth has been reached then evaluate the position and return the Evaluation Result
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 Else
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 \tab For each legal move generated:
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 \tab \tab Use the temporary board to try that move 
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 \tab \tab Perform a minimizing buddy algorithm for the opponent
\par }\pard \ql \li0\ri0\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\faauto\rin0\lin0\itap0 {\fs20\lang1031\langfe1033\langnp1031 \tab \tab If the result returned by the buddy is better than any previous result then save the move leading to \tab 
\tab it as the Best Move
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 \tab Return the Best Move and the Best Result
\par }\pard \ql \li0\ri0\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\faauto\rin0\lin0\itap0 {\fs20\lang1031\langfe1033\langnp1031 
\par On the 'real' board make that move 
\par 
\par This is a dangerous modification though - if we stop recurs
ion we will not be able to see what's happening behind the search horizon. We might be losing a valuable piece in the next move and we don't know it. So we modify the algorithm again (introducing a so-called }{\b\fs20\lang1031\langfe1033\langnp1031 
Quiescence Search}{\fs20\lang1031\langfe1033\langnp1031 ). The idea is that we cannot evaluate a position unless we know that no material losses are imminent:
\par 
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 Copy the internal representation of the current board into a temporary store
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 Generate all legal moves for the side who's turn it is
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 If there are no legal moves the side to move has lost - return a Result to indicate this 
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 If a specific recursion depth has been reached and no Capturing moves have been generated evaluate the position and return the Evaluation Result
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 Else
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 \tab For each legal move generated:
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 \tab \tab Use the temporary board to try that move 
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 \tab \tab Perform a minimizing buddy algorithm for the opponent
\par }\pard \ql \li0\ri0\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\faauto\rin0\lin0\itap0 {\fs20\lang1031\langfe1033\langnp1031 \tab \tab If the result returned by the buddy is better than any previous result then save the move leading to \tab 
\tab it as the Best Move
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 \tab Return the Best Move and the Best Result
\par }\pard \ql \li0\ri0\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\faauto\rin0\lin0\itap0 {\fs20\lang1031\langfe1033\langnp1031 
\par On the 'real' board make that move 
\par 
\par This is the basic Minimax algorithm; it is very inefficient though for several reasons and the first major improvement was introduced in the 1970s in a program called Chess 4.something.
\par 
\par The idea behind this improvement is difficult to unders
tand and is called Alpha-Beta Cutoff. If we consider that Black is minimizing his value and that White is trying to find the Maximum of these Minimums we can see that as soon as Black has found a Minimum which is below White's Maximum we can stop searchin
g
 that branch of the Search tree. Black's minimum will not improve White's maximum and the only thing that can happen if we continue the Search is that Black's minimum will get even smaller, in any case the Result returned by Black will be irrelevant for W
hite because it will not affect White's maximum. This stopping the Search is called a Cutoff and cutoffs will drastically reduce the searched tree size -- if the Cutoff occurs as a result of the first moves analysed. 
\par 
\par To implement Cutoff we introduce two n
ew variables called Alpha and Beta and we are only interested in results that are between the two. We make two modifications the the algorithm at this time - the first combines White's and Black's algrithms into one only (now called NegaMax) and permit ea
ch side to view the value by it's own eyes and maximize it. To still retain the mini-maximizing we return the negative result instead:
\par 
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 Copy the internal representation of the current board into a temporary store
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 Generate all legal moves for the side who's turn it is
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 If there are no legal moves the side to move has lost - return a Result to indicate this 
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 If a specific recursion depth has been reached and no Capturing moves have been generated evaluate the position and return the Evaluation Result
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 Else
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 \tab For each legal move generated:
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 \tab \tab Use the temporary board to try that move 
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 \tab \tab Perform this algorithm for the opponent
\par }\pard \ql \li0\ri0\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\faauto\rin0\lin0\itap0 {\fs20\lang1031\langfe1033\langnp1031 \tab \tab If the (result * -1) returned by this algorithm better than any previous result then save the move 
\par  \tab \tab leading to it as the Best Move
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 \tab Return the Best Move and the Best Result
\par }\pard \ql \li0\ri0\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\faauto\rin0\lin0\itap0 {\fs20\lang1031\langfe1033\langnp1031 
\par On the 'real' board make that move 
\par 
\par And now Alpha Beta Cutoff:
\par 
\par Set Alpha to the lowest value which the Search might return (-infinity)
\par Set Beta to the highest value which the Search might return (+infinity)
\par Perform the following algorithm using Alpha and Beta
\par 
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 Copy the internal representation of the current board into a temporary store
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 Generate all legal moves for the side who's turn it is
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 If there are no legal moves the side to move has lost - return a Result to indicate this 
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 If a specific recursion depth has been reached and no Capturing moves have been generated evaluate the position and return the Evaluation Result
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 Else
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 \tab For each legal move generated:
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031                 \tab If the Best Result is not less than Beta then exit the For Loop  //this is the cutoff  
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 \tab \tab Use the temporary board to try that move 
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031          \tab If the Best Result is greater than  Alpha then  Alpha = Best Result
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 \tab \tab Perform this algorithm for the opponent using (-Beta) as Alpha and (-Apha) as Beta
\par }\pard \ql \li0\ri0\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\faauto\rin0\lin0\itap0 {\fs20\lang1031\langfe1033\langnp1031 \tab \tab If the (result * -1) returned by this algorithm is better than any previous result then save the move 
\par \tab \tab leading to it as the Best Move
\par {\pntext\pard\plain\f3\fs20\lang1031\langfe1033\langnp1031 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-360\li360\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\faauto\ls1\rin0\lin360\itap0 {
\fs20\lang1031\langfe1033\langnp1031 \tab Return the Best Move and the Best Result
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\fs20\lang1031\langfe1033\langnp1031 
\par On the 'real' board make that move 
\par 
\par The savings come from the early exit out of the For Loop - and it is obvious that we save more if we exit as early as possible. 
\par 
\par But how can we achieve an early exit? The obvious answer is that we have to make the most promising move first.
\par 
\par On the other hand we do not know what the most promising move is until the Search returns a promising move. As you expect the solution to that follows:
\par 
\par We do Searches with increasing depths and use the result of those to do deeper Searches hoping that we can gain the time we spend on the Preliminary Searches throu
gh Cutoffs during the Deeper Searches. This is in fact so and this technique is called Iterative Deepening. It works best if we have a most promising move ready at each recursion level of the Search. To this end we have to introduce a new term called Prin
cipal Variation. The Principal Variation is a list of alternate Best Moves for both sides.
\par 
\par Before I describe how the Principal Variation is built and used I have to mention another positive side effect of the Iterative Deepening technique. In most games th
e rules set a time limit for each move or for a specified number of moves. If we embarked on a full Search right away, we cannot be sure whether we can complete that Search within the time required; however with  increasingly larger Searches we can always
 stop when time is up and we have a resulting best move ready from the Searches we were able to complete.
\par 
\par }{\b\fs20\lang1031\langfe1033\langnp1031 The Principal Variation 
\par }{\fs20\lang1031\langfe1033\langnp1031 requires that each move in it be a best move. So we have to use a kind of backtrack procedure to record the best move and that works as follows:
\par 
\par We set up a two-dimensional array of moves and while we are proceeding to deeper Search levels we clear any moves that may be present in this array from previous Searches (in the arrayelement (depth, depth)). When we then go up again a
nd have a best move we record that in the arrayelement (depth, depth) and as we know that the arrayelement (depth + 1, depth + 1) might also contain a best move we copy that to arrayelement (depth + 1, depth) and so forth with all moves beyound our curren
t
 Search depth. Thus we are using only the top right triangle of the two dimensional array, but when we exit the Search we have made sure that the top row contains best moves only. This is difficult to understand and it may help if you make a diagram of it
 and study the behaviour on that.
\par 
\par When we then embark on the next deeper Search we have a reservoir of best moves for every depth of the new Search except the last. And as these are best moves we have an A1 chance that they will trigger Cutoffs; so all we 
have to do is to explore those before all other generated moves.
\par 
\par }{\b\fs20\lang1031\langfe1033\langnp1031 Thinking on Opponent's Time
\par }{\fs20\lang1031\langfe1033\langnp1031 When the Search returns, the second move i
n the Principal Variation is the move that we think the opponent should make. So we set aside a copy of the board and make it there. The third move in the Principal Variation is our answer to the opponent's presumed move. Therefore it seems reasonable to 
e
mbark on a new Search starting off with our Principle Variation at that third move; we can even leave out a few of the preliminary Searches, if the Principle Variation permits that. If the opponent then makes the move we thought he should make we're well 
off. We are far into our next Search and simply continue it. If the opponent makes a different move however then we will have to abandon our Search and restart it with the position created by the opponent's move.
\par 
\par 
\par I will now describe some further refinements that may be used to make the Search more efficient:
\par 
\par }{\b\fs20\lang1031\langfe1033\langnp1031 The Killer Move Heuristics
\par }{\fs20\lang1031\langfe1033\langnp1031 In some circumstances the Principal Variation may fail to produce a Cutoff  and it would be stupid if we did not have another card up our sleeve. If we have found a move in 
a Search tree branch that did trigger a Cutoff chances are good that this move will also trigger a Cutoff in a neighboring branch af the Search tree. So we keep a list of moves that triggered a Cutoff (one, or better two, moves for each depth level; two m
o
ves because if we had only one and we find in a branch that another move triggered Cutoff we would have to discard a succesful move to save this new succesful one). If the Principal Variation move failed to trigger a Cutoff we then explore the two killer 
moves hoping that one of them will be successful again in producing a Cutoff.
\par 
\par }{\b\fs20\lang1031\langfe1033\langnp1031 Capture Back
\par }{\fs20\lang1031\langfe1033\langnp1031 You will have to remember that the Search is blind for any strategic deliberations and just examines move after move. So chances are great that a piece which has jus
t captured one of our pieces is unprotected. If the two Killer moves still did not trigger a Cutoff  and we can identify such a piece we try to capture back thus falsifying the origial capture and possibly triggering Cutoff.
\par 
\par }{\b\fs20\lang1031\langfe1033\langnp1031 All other Captures}{\fs20\lang1031\langfe1033\langnp1031 
\par Captures of
 course influence the material balance in our favour and may therefore trigger a Cutoff. And the Position Evaluation is such that it will rarely return a value which exceeds the value of our cheapest piece - this is so that the Search will not sacrifice p
ieces for a  position of which the Position Evaluation thinks it's good. The values for pieces are fixed whereas the value of a position is only an estimate by the Position Evaluation and that cannot always be trusted.
\par 
\par }{\b\fs20\lang1031\langfe1033\langnp1031 Aspiration Search}{\fs20\lang1031\langfe1033\langnp1031 
\par When we embark on a
 Search we do that with a completely open Alpha - Beta window and therefore the first level of the Search will never produce a Cutoff. Experience however tells us that changes in positional and material value are slowly changing from move to move and it w
o
uld be good if the first Search level would also produce Cutoffs because they are the most efficient ones. So we attempt to make the Alpha - Beta window more narrow when we do the next iteration of our  Iterative Search Deepening. We have the result of th
e
 previous iteration and we do not expect that the result will change much during the next iteration. So it is a good idea to start the next iteration with a narrower window around the value we know - if that succeds we have probably cut off large parts of
 
the Search tree; however if the Search returns with a value outside the initial Alpha - Beta window we have cut off the wrong branches of the tree and  we will have to repeat that iteration with a fully open window. The net gain is normally bigger than th
e loss through these occasional re-searches.
\par 
\par }{\b\fs20\lang1031\langfe1033\langnp1031 Transposition Table}{\fs20\lang1031\langfe1033\langnp1031 
\par The Search is stupid. It does not realize that a position can be created by several different move sequences. For example - White moves piece A, then Black moves piece B and finally White moves his piece C, resulting in a specific position.
\par If White had moved his piece C first and later his piece A (with the same intervening move of Black) the resulting position is the same and the Search will explore the same parts of the tree again. This is 
were the transposition table comes in. It stores a (large) number of positions which have already been visited and if the same position occurs again during a Search it can cut off that part of the tree and just supply the value that had been assigned to t
h
at position before. Access to the transposition table must therefore be faster than re-searching parts of the tree so that any savings can be realized. So a type of hashing algorithm is used to find a position in the transposition table and collisions are
 eliminated only very little; if a collision cannot be resolved within a few steps it may be cheaper on time to re-search the tree.
\par }}